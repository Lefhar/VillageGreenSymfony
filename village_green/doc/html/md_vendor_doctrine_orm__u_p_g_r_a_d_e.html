<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>village green: Upgrade to 2.11</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">village green
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Upgrade to 2.11 </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md225"></a>
Rename &lt;tt&gt;AbstractIdGenerator::generate()&lt;/tt&gt; to &lt;tt&gt;generateId()&lt;/tt&gt;</h1>
<p >Implementations of <code>AbstractIdGenerator</code> have to override the method <code>generateId()</code> without calling the parent implementation. Not doing so is deprecated. Calling <code>generate()</code> on any <code>AbstractIdGenerator</code> implementation is deprecated.</p>
<h1><a class="anchor" id="autotoc_md226"></a>
PSR-6-based second level cache</h1>
<p >The second level cache has been reworked to consume a PSR-6 cache. Using a Doctrine Cache instance is deprecated.</p>
<ul>
<li><code>DefaultCacheFactory</code>: The constructor expects a PSR-6 cache item pool as second argument now.</li>
<li><code>DefaultMultiGetRegion</code>: This class is deprecated in favor of <code>DefaultRegion</code>.</li>
<li><code>DefaultRegion</code>:<ul>
<li>The constructor expects a PSR-6 cache item pool as second argument now.</li>
<li>The protected <code>$cache</code> property is deprecated.</li>
<li>The properties <code>$name</code> and <code>$lifetime</code> as well as the constant <code>REGION_KEY_SEPARATOR</code> and the method <code>getCacheEntryKey()</code> are flagged as <code>@internal</code> now. They all will become <code>private</code> in 3.0.</li>
<li>The method <code>getCache()</code> is deprecated without replacement.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md227"></a>
Deprecated: &lt;tt&gt;Doctrine\ORM\Mapping\Driver\PHPDriver&lt;/tt&gt;</h1>
<p >Use <code>StaticPHPDriver</code> instead when you want to programmatically configure entity metadata.</p>
<p >You can convert mappings with the <code>orm:convert-mapping</code> command or more simply in this case, <code>include</code> the metadata file from the <code>loadMetadata</code> static method used by the <code>StaticPHPDriver</code>.</p>
<h1><a class="anchor" id="autotoc_md228"></a>
Deprecated: &lt;tt&gt;Setup::registerAutoloadDirectory()&lt;/tt&gt;</h1>
<p >Use Composer's autoloader instead.</p>
<h1><a class="anchor" id="autotoc_md229"></a>
Deprecated: &lt;tt&gt;AbstractHydrator::hydrateRow()&lt;/tt&gt;</h1>
<p >Following the deprecation of the method <code>AbstractHydrator::iterate()</code>, the method <code>hydrateRow()</code> has been deprecated as well.</p>
<h1><a class="anchor" id="autotoc_md230"></a>
Deprecate cache settings inspection</h1>
<p >Doctrine does not provide its own cache implementation anymore and relies on the PSR-6 standard instead. As a consequence, we cannot determine anymore whether a given cache adapter is suitable for a production environment. Because of that, functionality that aims to do so has been deprecated:</p>
<ul>
<li><code>Configuration::ensureProductionSettings()</code></li>
<li>the <code>orm:ensure-production-settings</code> console command</li>
</ul>
<h1><a class="anchor" id="autotoc_md231"></a>
Upgrade to 2.10</h1>
<h2><a class="anchor" id="autotoc_md232"></a>
BC Break: &lt;tt&gt;UnitOfWork&lt;/tt&gt; now relies on SPL object IDs, not hashes</h2>
<p >When calling the following methods, you are now supposed to use the result of <code>spl_object_id()</code>, and not <code>spl_object_hash()</code>:</p><ul>
<li><code>UnitOfWork::clearEntityChangeSet()</code></li>
<li><code>UnitOfWork::setOriginalEntityProperty()</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md233"></a>
BC Break: Removed &lt;tt&gt;TABLE&lt;/tt&gt; id generator strategy</h2>
<p >The implementation was unfinished for 14 years. It is now deprecated to rely on:</p><ul>
<li><code>Doctrine\ORM\Id\TableGenerator</code>;</li>
<li><code>Doctrine\ORM\Mapping\ClassMetadata::GENERATOR_TYPE_TABLE</code>;</li>
<li><code>Doctrine\ORM\Mapping\ClassMetadata::$tableGeneratorDefinition</code>;</li>
<li>or <code>Doctrine\ORM\Mapping\ClassMetadata::isIdGeneratorTable()</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md234"></a>
New method &lt;tt&gt;Doctrine\ORM\EntityManagerInterface#wrapInTransaction($func)&lt;/tt&gt;</h2>
<p >Works the same as <code>Doctrine\ORM\EntityManagerInterface#transactional()</code> but returns any value returned from <code>$func</code> closure rather than just <em>non-empty value returned from the closure or true</em>.</p>
<p >Because of BC policy, the method does not exist on the interface yet. This is the example of safe usage:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> foo(EntityManagerInterface $entityManager, callable $func) {</div>
<div class="line">    <span class="keywordflow">if</span> (method_exists($entityManager, <span class="stringliteral">&#39;wrapInTransaction&#39;</span>)) {</div>
<div class="line">        <span class="keywordflow">return</span> $entityManager-&gt;wrapInTransaction($func);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> $entityManager-&gt;transactional($func);</div>
<div class="line">}</div>
</div><!-- fragment --><p ><code>Doctrine\ORM\EntityManagerInterface#transactional()</code> has been deprecated.</p>
<h2><a class="anchor" id="autotoc_md235"></a>
Minor BC BREAK: some exception methods have been removed</h2>
<p >The following methods were not in use and are very unlikely to be used by downstream packages or applications, and were consequently removed:</p>
<ul>
<li><code>ORMException::entityMissingForeignAssignedId</code></li>
<li><code>ORMException::entityMissingAssignedIdForField</code></li>
<li><code>ORMException::invalidFlushMode</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md236"></a>
Deprecated: database-side UUID generation</h2>
<p ><a href="https://github.com/doctrine/dbal/pull/3212">DB-generated UUIDs are deprecated as of <code>doctrine/dbal</code> 2.8</a>. As a consequence, using the <code>UUID</code> strategy for generating identifiers is deprecated as well. Furthermore, relying on the following classes and methods is deprecated:</p>
<ul>
<li><code>Doctrine\ORM\Id\UuidGenerator</code></li>
<li><code>Doctrine\ORM\Mapping\ClassMetadataInfo::isIdentifierUuid()</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md237"></a>
Minor BC BREAK: Custom hydrators and &lt;tt&gt;toIterable()&lt;/tt&gt;</h2>
<p >The type declaration of the <code>$stmt</code> parameter of <code>AbstractHydrator::toIterable()</code> has been removed. This change might break custom hydrator implementations that override this very method.</p>
<p >Overriding this method is not recommended, which is why the method is documented as <code>@final</code> now.</p>
<div class="fragment"><div class="line">- public function toIterable(ResultStatement $stmt, ResultSetMapping $resultSetMapping, array $hints = []): iterable</div>
<div class="line">+ public function toIterable($stmt, ResultSetMapping $resultSetMapping, array $hints = []): iterable</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md238"></a>
Deprecated: Entity Namespace Aliases</h2>
<p >Entity namespace aliases are deprecated, use the magic ::class constant to abbreviate full class names in EntityManager, EntityRepository and DQL.</p>
<div class="fragment"><div class="line">-  $entityManager-&gt;find(&#39;MyBundle:User&#39;, $id);</div>
<div class="line">+  $entityManager-&gt;find(User::class, $id);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md239"></a>
Upgrade to 2.9</h1>
<h2><a class="anchor" id="autotoc_md240"></a>
Minor BC BREAK: Setup tool needs cache implementation</h2>
<p >With the deprecation of doctrine/cache, the setup tool might no longer work as expected without a different cache implementation. To work around this:</p><ul>
<li>Install symfony/cache: <code>composer require symfony/cache</code>. This will keep previous behaviour without any changes</li>
<li>Instantiate caches yourself: to use a different cache implementation, pass a cache instance when calling any configuration factory in the setup tool: <div class="fragment"><div class="line">- $config = Setup::createAnnotationMetadataConfiguration($paths, $isDevMode, $proxyDir);</div>
<div class="line">+ $cache = \Doctrine\Common\Cache\Psr6\DoctrineProvider::wrap($anyPsr6Implementation);</div>
<div class="line">+ $config = Setup::createAnnotationMetadataConfiguration($paths, $isDevMode, $proxyDir, $cache);</div>
</div><!-- fragment --></li>
<li>As a quick workaround, you can lock the doctrine/cache dependency to work around this: <code>composer require doctrine/cache ^1.11</code>. Note that this is only recommended as a bandaid fix, as future versions of ORM will no longer work with doctrine/cache 1.11.</li>
</ul>
<h2><a class="anchor" id="autotoc_md241"></a>
Deprecated: doctrine/cache for metadata caching</h2>
<p >The <code>Doctrine\ORM\Configuration#setMetadataCacheImpl()</code> method is deprecated and should no longer be used. Please use <code>Doctrine\ORM\Configuration#setMetadataCache()</code> with any PSR-6 cache adapter instead.</p>
<h2><a class="anchor" id="autotoc_md242"></a>
Removed: flushing metadata cache</h2>
<p >To support PSR-6 caches, the <code>--flush</code> option for the <code>orm:clear-cache:metadata</code> command is ignored. Metadata cache is now always cleared regardless of the cache adapter being used.</p>
<h1><a class="anchor" id="autotoc_md243"></a>
Upgrade to 2.8</h1>
<h2><a class="anchor" id="autotoc_md244"></a>
Minor BC BREAK: Failed commit now throw OptimisticLockException</h2>
<p >Method <code>Doctrine\ORM\UnitOfWork#commit()</code> can throw an OptimisticLockException when a commit silently fails and returns false since <code>Doctrine\DBAL\Connection#commit()</code> signature changed from returning void to boolean</p>
<h2><a class="anchor" id="autotoc_md245"></a>
Deprecated: &lt;tt&gt;Doctrine\ORM\AbstractQuery#iterate()&lt;/tt&gt;</h2>
<p >The method <code>Doctrine\ORM\AbstractQuery#iterate()</code> is deprecated in favor of <code>Doctrine\ORM\AbstractQuery#toIterable()</code>. Note that <code>toIterable()</code> yields results of the query, unlike <code>iterate()</code> which yielded each result wrapped into an array.</p>
<h1><a class="anchor" id="autotoc_md246"></a>
Upgrade to 2.7</h1>
<h2><a class="anchor" id="autotoc_md247"></a>
Added &lt;tt&gt;Doctrine\ORM\AbstractQuery#enableResultCache()&lt;/tt&gt; and &lt;tt&gt;Doctrine\ORM\AbstractQuery#disableResultCache()&lt;/tt&gt; methods</h2>
<p >Method <code>Doctrine\ORM\AbstractQuery#useResultCache()</code> which could be used for both enabling and disabling the cache (depending on passed flag) was split into two. <br  />
</p>
<h2><a class="anchor" id="autotoc_md248"></a>
Minor BC BREAK: paginator output walkers aren't be called anymore on sub-queries for queries without max results</h2>
<p >To optimize DB interaction, <code>Doctrine\ORM\<a class="el" href="namespace_tools.html">Tools</a>\Pagination\Paginator</code> no longer fetches identifiers to be able to perform the pagination with join collections when max results isn't set in the query.</p>
<h2><a class="anchor" id="autotoc_md249"></a>
Minor BC BREAK: tables filtered with &lt;tt&gt;schema_filter&lt;/tt&gt; are no longer created</h2>
<p >When generating schema diffs, if a source table is filtered out by a <code>schema_filter</code> expression, then a <code>CREATE TABLE</code> was always generated, even if the table already existed. This has been changed in this release and the table will no longer be created.</p>
<h2><a class="anchor" id="autotoc_md250"></a>
Deprecated number unaware &lt;tt&gt;Doctrine\ORM\Mapping\UnderscoreNamingStrategy&lt;/tt&gt;</h2>
<p >In the last patch of the <code>v2.6.x</code> series, we fixed a bug that was not converting names properly when they had numbers (e.g.: <code>base64Encoded</code> was wrongly converted to <code>base64encoded</code> instead of <code>base64_encoded</code>).</p>
<p >In order to not break BC we've introduced a way to enable the fixed behavior using a boolean constructor argument. This argument will be removed in 3.0 and the default behavior will be the fixed one.</p>
<h2><a class="anchor" id="autotoc_md251"></a>
Deprecated: &lt;tt&gt;Doctrine\ORM\AbstractQuery#useResultCache()&lt;/tt&gt;</h2>
<p >Method <code>Doctrine\ORM\AbstractQuery#useResultCache()</code> is deprecated because it is split into <code>enableResultCache()</code> and <code>disableResultCache()</code>. It will be removed in 3.0.</p>
<h2><a class="anchor" id="autotoc_md252"></a>
Deprecated code generators and related console commands</h2>
<p >These console commands have been deprecated:</p>
<ul>
<li><code>orm:convert-mapping</code></li>
<li><code>orm:generate:entities</code></li>
<li><code>orm:generate-repositories</code></li>
</ul>
<p >These classes have been deprecated:</p>
<ul>
<li><code>Doctrine\ORM\<a class="el" href="namespace_tools.html">Tools</a>\EntityGenerator</code></li>
<li><code>Doctrine\ORM\<a class="el" href="namespace_tools.html">Tools</a>\EntityRepositoryGenerator</code></li>
</ul>
<p >Whole Doctrine\ORM\Tools\Export namespace with all its members have been deprecated as well.</p>
<h2><a class="anchor" id="autotoc_md253"></a>
Deprecated &lt;tt&gt;Doctrine\ORM\Proxy\Proxy&lt;/tt&gt; marker interface</h2>
<p >Proxy objects in Doctrine ORM 3.0 will no longer implement <code>Doctrine\ORM\Proxy\Proxy</code> nor <code>Doctrine\Persistence\Proxy</code>: instead, they implement <code>ProxyManager\Proxy\GhostObjectInterface</code>.</p>
<p >These related classes have been deprecated:</p>
<ul>
<li><code>Doctrine\ORM\Proxy\ProxyFactory</code></li>
<li><code>Doctrine\ORM\Proxy\Autoloader</code> - we suggest using the composer autoloader instead</li>
</ul>
<p >These methods have been deprecated:</p>
<ul>
<li><code>Doctrine\ORM\Configuration#getAutoGenerateProxyClasses()</code></li>
<li><code>Doctrine\ORM\Configuration#getProxyDir()</code></li>
<li><code>Doctrine\ORM\Configuration#getProxyNamespace()</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md254"></a>
Deprecated &lt;tt&gt;Doctrine\ORM\Version&lt;/tt&gt;</h2>
<p >The <code>Doctrine\ORM\Version</code> class is now deprecated and will be removed in Doctrine ORM 3.0: please refrain from checking the ORM version at runtime or use Composer's <a href="https://getcomposer.org/doc/07-runtime.md#knowing-whether-package-x-is-installed-in-version-y">runtime API</a>.</p>
<h2><a class="anchor" id="autotoc_md255"></a>
Deprecated &lt;tt&gt;EntityManager#merge()&lt;/tt&gt; method</h2>
<p >Merge semantics was a poor fit for the PHP "share-nothing" architecture. In addition to that, merging caused multiple issues with data integrity in the managed entity graph, which was constantly spawning more edge-case bugs/scenarios.</p>
<p >The following API methods were therefore deprecated:</p>
<ul>
<li><code>EntityManager#merge()</code></li>
<li><code>UnitOfWork#merge()</code></li>
</ul>
<p >An alternative to <code>EntityManager#merge()</code> will not be provided by ORM 3.0, since the merging semantics should be part of the business domain rather than the persistence domain of an application. If your application relies heavily on CRUD-alike interactions and/or <code>PATCH</code> restful operations, you should look at alternatives such as <a href="https://github.com/schmittjoh/serializer">JMSSerializer</a>.</p>
<h2><a class="anchor" id="autotoc_md256"></a>
Extending &lt;tt&gt;EntityManager&lt;/tt&gt; is deprecated</h2>
<p >Final keyword will be added to the <code>EntityManager::class</code> in Doctrine ORM 3.0 in order to ensure that EntityManager is not used as valid extension point. Valid extension point should be EntityManagerInterface.</p>
<h2><a class="anchor" id="autotoc_md257"></a>
Deprecated &lt;tt&gt;EntityManager#clear($entityName)&lt;/tt&gt;</h2>
<p >If your code relies on clearing a single entity type via <code>EntityManager#clear($entityName)</code>, the signature has been changed to <code>EntityManager#clear()</code>.</p>
<p >The main reason is that partial clears caused multiple issues with data integrity in the managed entity graph, which was constantly spawning more edge-case bugs/scenarios.</p>
<h2><a class="anchor" id="autotoc_md258"></a>
Deprecated &lt;tt&gt;EntityManager#flush($entity)&lt;/tt&gt; and &lt;tt&gt;EntityManager#flush($entities)&lt;/tt&gt;</h2>
<p >If your code relies on single entity flushing optimisations via <code>EntityManager#flush($entity)</code>, the signature has been changed to <code>EntityManager#flush()</code>.</p>
<p >Said API was affected by multiple data integrity bugs due to the fact that change tracking was being restricted upon a subset of the managed entities. The ORM cannot support committing subsets of the managed entities while also guaranteeing data integrity, therefore this utility was removed.</p>
<p >The <code>flush()</code> semantics will remain the same, but the change tracking will be performed on all entities managed by the unit of work, and not just on the provided <code>$entity</code> or <code>$entities</code>, as the parameter is now completely ignored.</p>
<p >The same applies to <code>UnitOfWork#commit($entity)</code>, which will simply be <code>UnitOfWork#commit()</code>.</p>
<p >If you would still like to perform batching operations over small <code>UnitOfWork</code> instances, it is suggested to follow these paths instead:</p>
<ul>
<li>eagerly use <code>EntityManager#clear()</code> in conjunction with a specific second level cache configuration (see <a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/second-level-cache.html">http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/second-level-cache.html</a>)</li>
<li>use an explicit change tracking policy (see <a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/change-tracking-policies.html">http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/change-tracking-policies.html</a>)</li>
</ul>
<h2><a class="anchor" id="autotoc_md259"></a>
Deprecated &lt;tt&gt;YAML&lt;/tt&gt; mapping drivers.</h2>
<p >If your code relies on <code>YamlDriver</code> or <code>SimpleYamlDriver</code>, you <b>MUST</b> change to annotation or XML drivers instead.</p>
<h2><a class="anchor" id="autotoc_md260"></a>
Deprecated: &lt;tt&gt;Doctrine\ORM\EntityManagerInterface#copy()&lt;/tt&gt;</h2>
<p >Method <code>Doctrine\ORM\EntityManagerInterface#copy()</code> never got its implementation and is deprecated. It will be removed in 3.0.</p>
<h1><a class="anchor" id="autotoc_md261"></a>
Upgrade to 2.6</h1>
<h2><a class="anchor" id="autotoc_md262"></a>
Added &lt;tt&gt;Doctrine\ORM\EntityRepository::count()&lt;/tt&gt; method</h2>
<p ><code>Doctrine\ORM\EntityRepository::count()</code> has been added. This new method has different signature than <code>Countable::count()</code> (required parameter) and therefore are not compatible. If your repository implemented the <code>Countable</code> interface, you will have to use <code>$repository-&gt;count([])</code> instead and not implement <code>Countable</code> interface anymore.</p>
<h2><a class="anchor" id="autotoc_md263"></a>
Minor BC BREAK: &lt;tt&gt;Doctrine\ORM\Tools\Console\ConsoleRunner&lt;/tt&gt; is now final</h2>
<p >Since it's just an utilitarian class and should not be inherited.</p>
<h2><a class="anchor" id="autotoc_md264"></a>
Minor BC BREAK: removed &lt;tt&gt;Doctrine\ORM\Query\QueryException::associationPathInverseSideNotSupported()&lt;/tt&gt;</h2>
<p >Method <code>Doctrine\ORM\Query\QueryException::associationPathInverseSideNotSupported()</code> now has a required parameter <code>$pathExpr</code>.</p>
<h2><a class="anchor" id="autotoc_md265"></a>
Minor BC BREAK: removed &lt;tt&gt;Doctrine\ORM\Query\Parser#isInternalFunction()&lt;/tt&gt;</h2>
<p >Method <code>Doctrine\ORM\Query\Parser#isInternalFunction()</code> was removed because the distinction between internal function and user defined DQL was removed. <a href="https://github.com/doctrine/orm/pull/6500">#6500</a></p>
<h2><a class="anchor" id="autotoc_md266"></a>
Minor BC BREAK: removed &lt;tt&gt;Doctrine\ORM\ORMException#overwriteInternalDQLFunctionNotAllowed()&lt;/tt&gt;</h2>
<p >Method <code>Doctrine\ORM\Query\Parser#overwriteInternalDQLFunctionNotAllowed()</code> was removed because of the choice to allow users to overwrite internal functions, ie <code>AVG</code>, <code>SUM</code>, <code>COUNT</code>, <code>MIN</code> and <code>MAX</code>. <a href="https://github.com/doctrine/orm/pull/6500">#6500</a></p>
<h2><a class="anchor" id="autotoc_md267"></a>
PHP 7.1 is now required</h2>
<p >Doctrine 2.6 now requires PHP 7.1 or newer.</p>
<p >As a consequence, automatic cache setup in Doctrine\ORM\Tools\Setup::create*Configuration() was changed:</p><ul>
<li>APCu extension (ext-apcu) will now be used instead of abandoned APC (ext-apc).</li>
<li>Memcached extension (ext-memcached) will be used instead of obsolete Memcache (ext-memcache).</li>
<li>XCache support was dropped as it doesn't work with PHP 7.</li>
</ul>
<h1><a class="anchor" id="autotoc_md268"></a>
Upgrade to 2.5</h1>
<h2><a class="anchor" id="autotoc_md269"></a>
Minor BC BREAK: removed &lt;tt&gt;Doctrine\ORM\Query\SqlWalker#walkCaseExpression()&lt;/tt&gt;</h2>
<p >Method <code>Doctrine\ORM\Query\SqlWalker#walkCaseExpression()</code> was unused and part of the internal API of the ORM, so it was removed. <a href="https://github.com/doctrine/orm/pull/5600">#5600</a>.</p>
<h2><a class="anchor" id="autotoc_md270"></a>
Minor BC BREAK: removed $className parameter on &lt;tt&gt;AbstractEntityInheritancePersister#getSelectJoinColumnSQL()&lt;/tt&gt;</h2>
<p >As <code>$className</code> parameter was not used in the method, it was safely removed.</p>
<h2><a class="anchor" id="autotoc_md271"></a>
Minor BC BREAK: query cache key time is now a float</h2>
<p >As of 2.5.5, the <code>QueryCacheEntry#time</code> property will contain a float value instead of an integer in order to have more precision and also to be consistent with the <code>TimestampCacheEntry#time</code>.</p>
<h2><a class="anchor" id="autotoc_md272"></a>
Minor BC BREAK: discriminator map must now include all non-transient classes</h2>
<p >It is now required that you declare the root of an inheritance in the discriminator map.</p>
<p >When declaring an inheritance map, it was previously possible to skip the root of the inheritance in the discriminator map. This was actually a validation mistake by Doctrine2 and led to problems when trying to persist instances of that class.</p>
<p >If you don't plan to persist instances some classes in your inheritance, then either:</p>
<ul>
<li>make those classes <code>abstract</code></li>
<li>map those classes as <code>MappedSuperclass</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md273"></a>
Minor BC BREAK: &lt;tt&gt;EntityManagerInterface&lt;/tt&gt; instead of &lt;tt&gt;EntityManager&lt;/tt&gt; in type-hints</h2>
<p >As of 2.5, classes requiring the <code>EntityManager</code> in any method signature will now require an <code>EntityManagerInterface</code> instead. If you are extending any of the following classes, then you need to check following signatures:</p>
<ul>
<li><code>Doctrine\ORM\<a class="el" href="namespace_tools.html">Tools</a>\DebugUnitOfWorkListener#dumpIdentityMap(EntityManagerInterface $em)</code></li>
<li><code>Doctrine\ORM\Mapping\ClassMetadataFactory#setEntityManager(EntityManagerInterface $em)</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md274"></a>
Minor BC BREAK: Custom Hydrators API change</h2>
<p >As of 2.5, <code>AbstractHydrator</code> does not enforce the usage of cache as part of API, and now provides you a clean API for column information through the method <code>hydrateColumnInfo($column)</code>. Cache variable being passed around by reference is no longer needed since Hydrators are per query instantiated since Doctrine 2.4.</p>
<h2><a class="anchor" id="autotoc_md275"></a>
Minor BC BREAK: Entity based &lt;tt&gt;EntityManager#clear()&lt;/tt&gt; calls follow cascade detach</h2>
<p >Whenever <code>EntityManager#clear()</code> method gets called with a given entity class name, until 2.4, it was only detaching the specific requested entity. As of 2.5, <code>EntityManager</code> will follow configured cascades, providing a better memory management since associations will be garbage collected, optimizing resources consumption on long running jobs.</p>
<h2><a class="anchor" id="autotoc_md276"></a>
BC BREAK: NamingStrategy interface changes</h2>
<ol type="1">
<li>A new method <code>embeddedFieldToColumnName($propertyName, $embeddedColumnName)</code></li>
</ol>
<p >This method generates the column name for fields of embedded objects. If you implement your custom NamingStrategy, you now also need to implement this new method.</p>
<ol type="1">
<li>A change to method <code>joinColumnName()</code> to include the $className</li>
</ol>
<h2><a class="anchor" id="autotoc_md277"></a>
Updates on entities scheduled for deletion are no longer processed</h2>
<p >In Doctrine 2.4, if you modified properties of an entity scheduled for deletion, UnitOfWork would produce an UPDATE statement to be executed right before the DELETE statement. The entity in question was therefore present in <code>UnitOfWork#entityUpdates</code>, which means that <code>preUpdate</code> and <code>postUpdate</code> listeners were (quite pointlessly) called. In <code>preFlush</code> listeners, it used to be possible to undo the scheduled deletion for updated entities (by calling <code>persist()</code> if the entity was found in both <code>entityUpdates</code> and <code>entityDeletions</code>). This does not work any longer, because the entire changeset calculation logic is optimized away.</p>
<h2><a class="anchor" id="autotoc_md278"></a>
Minor BC BREAK: Default lock mode changed from LockMode::NONE to null in method signatures</h2>
<p >A misconception concerning default lock mode values in method signatures lead to unexpected behaviour in SQL statements on SQL Server. With a default lock mode of <code>LockMode::NONE</code> throughout the method signatures in ORM, the table lock hint <code>WITH (NOLOCK)</code> was appended to all locking related queries by default. This could result in unpredictable results because an explicit <code>WITH (NOLOCK)</code> table hint tells SQL Server to run a specific query in transaction isolation level READ UNCOMMITTED instead of the default READ COMMITTED transaction isolation level. Therefore there now is a distinction between <code>LockMode::NONE</code> and <code>null</code> to be able to tell Doctrine whether to add table lock hints to queries by intention or not. To achieve this, the following method signatures have been changed to declare <code>$lockMode = null</code> instead of <code>$lockMode = LockMode::NONE</code>:</p>
<ul>
<li><code>Doctrine\ORM\Cache\Persister\AbstractEntityPersister#getSelectSQL()</code></li>
<li><code>Doctrine\ORM\Cache\Persister\AbstractEntityPersister#load()</code></li>
<li><code>Doctrine\ORM\Cache\Persister\AbstractEntityPersister#refresh()</code></li>
<li><code>Doctrine\ORM\Decorator\EntityManagerDecorator#find()</code></li>
<li><code>Doctrine\ORM\EntityManager#find()</code></li>
<li><code>Doctrine\ORM\EntityRepository#find()</code></li>
<li><code>Doctrine\ORM\Persisters\BasicEntityPersister#getSelectSQL()</code></li>
<li><code>Doctrine\ORM\Persisters\BasicEntityPersister#load()</code></li>
<li><code>Doctrine\ORM\Persisters\BasicEntityPersister#refresh()</code></li>
<li><code>Doctrine\ORM\Persisters\EntityPersister#getSelectSQL()</code></li>
<li><code>Doctrine\ORM\Persisters\EntityPersister#load()</code></li>
<li><code>Doctrine\ORM\Persisters\EntityPersister#refresh()</code></li>
<li><code>Doctrine\ORM\Persisters\JoinedSubclassPersister#getSelectSQL()</code></li>
</ul>
<p >You should update signatures for these methods if you have subclassed one of the above classes. Please also check the calling code of these methods in your application and update if necessary.</p>
<p ><b>Note:</b> This in fact is really a minor BC BREAK and should not have any affect on database vendors other than SQL Server because it is the only one that supports and therefore cares about <code>LockMode::NONE</code>. It's really just a FIX for SQL Server environments using ORM.</p>
<h2><a class="anchor" id="autotoc_md279"></a>
Minor BC BREAK: &lt;tt&gt;__clone&lt;/tt&gt; method not called anymore when entities are instantiated via metadata API</h2>
<p >As of PHP 5.6, instantiation of new entities is deferred to the <a href="https://github.com/doctrine/instantiator"><code>doctrine/instantiator</code></a> library, which will avoid calling <code>__clone</code> or any public API on instantiated objects.</p>
<h2><a class="anchor" id="autotoc_md280"></a>
BC BREAK: &lt;tt&gt;Doctrine\ORM\Repository\DefaultRepositoryFactory&lt;/tt&gt; is now &lt;tt&gt;final&lt;/tt&gt;</h2>
<p >Please implement the <code>Doctrine\ORM\Repository\RepositoryFactory</code> interface instead of extending the <code>Doctrine\ORM\Repository\DefaultRepositoryFactory</code>.</p>
<h2><a class="anchor" id="autotoc_md281"></a>
BC BREAK: New object expression DQL queries now respects user provided aliasing and not return consumed fields</h2>
<p >When executing DQL queries with new object expressions, instead of returning DTOs numerically indexes, it will now respect user provided aliases. Consider the following query: </p><pre class="fragment">SELECT new UserDTO(u.id,u.name) as user,new AddressDTO(a.street,a.postalCode) as address, a.id as addressId FROM User u INNER JOIN u.addresses a WITH a.isPrimary = true
</pre><p> Previously, your result would be similar to this: </p><pre class="fragment">array(
    0=&gt;array(
        0=&gt;{UserDTO object},
        1=&gt;{AddressDTO object},
        2=&gt;{u.id scalar},
        3=&gt;{u.name scalar},
        4=&gt;{a.street scalar},
        5=&gt;{a.postalCode scalar},
        'addressId'=&gt;{a.id scalar},
    ),
    ...
)
</pre><p> From now on, the resultset will look like this: </p><pre class="fragment">array(
    0=&gt;array(
        'user'=&gt;{UserDTO object},
        'address'=&gt;{AddressDTO object},
        'addressId'=&gt;{a.id scalar}
    ),
    ...
)
</pre> <h2><a class="anchor" id="autotoc_md282"></a>
Minor BC BREAK: added second parameter $indexBy in EntityRepository#createQueryBuilder method signature</h2>
<p >Added way to access the underlying QueryBuilder::from() method's 'indexBy' parameter when using EntityRepository::createQueryBuilder()</p>
<h1><a class="anchor" id="autotoc_md283"></a>
Upgrade to 2.4</h1>
<h2><a class="anchor" id="autotoc_md284"></a>
BC BREAK: Compatibility Bugfix in PersistentCollection#matching()</h2>
<p >In Doctrine 2.3 it was possible to use the new <code>matching($criteria)</code> functionality by adding constraints for assocations based on ID: </p><pre class="fragment">Criteria::expr()-&gt;eq('association', $assocation-&gt;getId());
</pre><p> This functionality does not work on InMemory collections however, because in memory criteria compares object values based on reference. As of 2.4 the above code will throw an exception. You need to change offending code to pass the <code>$assocation</code> reference directly: </p><pre class="fragment">Criteria::expr()-&gt;eq('association', $assocation);
</pre> <h2><a class="anchor" id="autotoc_md285"></a>
Composer is now the default autoloader</h2>
<p >The test suite now runs with composer autoloading. Support for PEAR, and tarball autoloading is deprecated. Support for GIT submodules is removed.</p>
<h2><a class="anchor" id="autotoc_md286"></a>
OnFlush and PostFlush event always called</h2>
<p >Before 2.4 the postFlush and onFlush events were only called when there were actually entities that changed. Now these events are called no matter if there are entities in the UoW or changes are found.</p>
<h2><a class="anchor" id="autotoc_md287"></a>
Parenthesis are now considered in arithmetic expression</h2>
<p >Before 2.4 parenthesis are not considered in arithmetic primary expression. That's conceptually wrong, since it might result in wrong values. For example:</p>
<p >The DQL: </p><pre class="fragment">SELECT 100 / ( 2 * 2 ) FROM MyEntity
</pre><p> Before 2.4 it generates the SQL: </p><pre class="fragment">SELECT 100 / 2 * 2 FROM my_entity
</pre><p> Now parenthesis are considered, the previous DQL will generate: </p><pre class="fragment">SELECT 100 / (2 * 2) FROM my_entity
</pre> <h1><a class="anchor" id="autotoc_md288"></a>
Upgrade to 2.3</h1>
<h2><a class="anchor" id="autotoc_md289"></a>
Auto Discriminator Map breaks userland implementations with Listener</h2>
<p >The new feature to detect discriminator maps automatically when none are provided breaks userland implementations doing this with a listener in <code>loadClassMetadata</code> event.</p>
<h2><a class="anchor" id="autotoc_md290"></a>
EntityManager#find() not calls EntityRepository#find() anymore</h2>
<p >Previous to 2.3, calling <code>EntityManager#find()</code> would be delegated to <code>EntityRepository#find()</code>. This has lead to some unexpected behavior in the core of Doctrine when people have overwritten the find method in their repositories. That is why this behavior has been reversed in 2.3, and <code>EntityRepository#find()</code> calls <code>EntityManager#find()</code> instead.</p>
<h2><a class="anchor" id="autotoc_md291"></a>
EntityGenerator add*() method generation</h2>
<p >When generating an add*() method for a collection the EntityGenerator will now not use the Type-Hint to get the singular for the collection name, but use the field-name and strip a trailing "s" character if there is one.</p>
<h2><a class="anchor" id="autotoc_md292"></a>
Merge copies non persisted properties too</h2>
<p >When merging an entity in UoW not only mapped properties are copied, but also others.</p>
<h2><a class="anchor" id="autotoc_md293"></a>
Query, QueryBuilder and NativeQuery parameters &lt;em&gt;BC break&lt;/em&gt;</h2>
<p >From now on, parameters in queries is an ArrayCollection instead of a simple array. This affects heavily the usage of setParameters(), because it will not append anymore parameters to query, but will actually override the already defined ones. Whenever you are retrieving a parameter (ie. $query-&gt;getParameter(1)), you will receive an instance of Query\Parameter, which contains the methods "getName", "getValue" and "getType". Parameters are also only converted to when necessary, and not when they are set.</p>
<p >Also, related functions were affected:</p>
<ul>
<li>execute($parameters, $hydrationMode) the argument $parameters can be either an key=&gt;value array or an ArrayCollection instance</li>
<li>iterate($parameters, $hydrationMode) the argument $parameters can be either an key=&gt;value array or an ArrayCollection instance</li>
<li>setParameters($parameters) the argument $parameters can be either an key=&gt;value array or an ArrayCollection instance</li>
<li>getParameters() now returns ArrayCollection instead of array</li>
<li>getParameter($key) now returns Parameter instance instead of parameter value</li>
</ul>
<h2><a class="anchor" id="autotoc_md294"></a>
Query TreeWalker method renamed</h2>
<p >Internal changes were made to DQL and SQL generation. If you have implemented your own TreeWalker, you probably need to update it. The method walkJoinVariableDeclaration is now named walkJoin.</p>
<h2><a class="anchor" id="autotoc_md295"></a>
New methods in TreeWalker interface &lt;em&gt;BC break&lt;/em&gt;</h2>
<p >Two methods getQueryComponents() and setQueryComponent() were added to the TreeWalker interface and all its implementations including TreeWalkerAdapter, TreeWalkerChain and SqlWalker. If you have your own implementation not inheriting from one of the above you must implement these new methods.</p>
<h2><a class="anchor" id="autotoc_md296"></a>
Metadata Drivers</h2>
<p >Metadata drivers have been rewritten to reuse code from <code>Doctrine\Persistence</code>. Anyone who is using the <code>Doctrine\ORM\Mapping\Driver\Driver</code> interface should instead refer to <code>Doctrine\Persistence\Mapping\Driver\MappingDriver</code>. Same applies to <code>Doctrine\ORM\Mapping\Driver\AbstractFileDriver</code>: you should now refer to <code>Doctrine\Persistence\Mapping\Driver\FileDriver</code>.</p>
<p >Also, following mapping drivers have been deprecated, please use their replacements in Doctrine\Common as listed:</p>
<ul>
<li><code>Doctrine\ORM\Mapping\Driver\DriverChain</code> =&gt; <code>Doctrine\Persistence\Mapping\Driver\MappingDriverChain</code></li>
<li><code>Doctrine\ORM\Mapping\Driver\PHPDriver</code> =&gt; <code>Doctrine\Persistence\Mapping\Driver\PHPDriver</code></li>
<li><code>Doctrine\ORM\Mapping\Driver\StaticPHPDriver</code> =&gt; <code>Doctrine\Persistence\Mapping\Driver\StaticPHPDriver</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md297"></a>
Upgrade to 2.2</h1>
<h2><a class="anchor" id="autotoc_md298"></a>
ResultCache implementation rewritten</h2>
<p >The result cache is completely rewritten and now works on the database result level, not inside the ORM AbstractQuery anymore. This means that for result cached queries the hydration will now always be performed again, regardless of the hydration mode. Affected areas are:</p>
<ol type="1">
<li>Fixes the problem that entities coming from the result cache were not registered in the UnitOfWork leading to problems during EntityManager::flush. Calls to EntityManager::merge are not necessary anymore.</li>
<li>Affects the array hydrator which now includes the overhead of hydration compared to caching the final result.</li>
</ol>
<p >The API is backwards compatible however most of the getter methods on the <code>AbstractQuery</code> object are now deprecated in favor of calling AbstractQuery::getQueryCacheProfile(). This method returns a <code>Doctrine\DBAL\Cache\QueryCacheProfile</code> instance with access to result cache driver, lifetime and cache key.</p>
<h2><a class="anchor" id="autotoc_md299"></a>
EntityManager#getPartialReference() creates read-only entity</h2>
<p >Entities returned from EntityManager::getPartialReference() are now marked as read-only if they haven't been in the identity map before. This means objects of this kind never lead to changes in the UnitOfWork.</p>
<h2><a class="anchor" id="autotoc_md300"></a>
Fields omitted in a partial DQL query or a native query are never updated</h2>
<p >Fields of an entity that are not returned from a partial DQL Query or native SQL query will never be updated through an UPDATE statement.</p>
<h2><a class="anchor" id="autotoc_md301"></a>
Removed support for onUpdate in @JoinColumn</h2>
<p >The onUpdate foreign key handling makes absolutely no sense in an ORM. Additionally Oracle doesn't even support it. Support for it is removed.</p>
<h2><a class="anchor" id="autotoc_md302"></a>
Changes in Annotation Handling</h2>
<p >There have been some changes to the annotation handling in Common 2.2 again, that affect how people with old configurations from 2.0 have to configure the annotation driver if they don't use <code>Configuration::newDefaultAnnotationDriver()</code>: </p><pre class="fragment">// Register the ORM Annotations in the AnnotationRegistry
AnnotationRegistry::registerFile('path/to/Doctrine/ORM/Mapping/Driver/DoctrineAnnotations.php');

$reader = new \Doctrine\Common\Annotations\SimpleAnnotationReader();
$reader-&gt;addNamespace('Doctrine\ORM\Mapping');
$reader = new \Doctrine\Common\Annotations\CachedReader($reader, new ArrayCache());

$driver = new AnnotationDriver($reader, (array)$paths);

$config-&gt;setMetadataDriverImpl($driver);
</pre><h2><a class="anchor" id="autotoc_md303"></a>
Scalar mappings can now be omitted from DQL result</h2>
<p >You are now allowed to mark scalar SELECT expressions as HIDDEN an they are not hydrated anymore. Example:</p>
<p >SELECT u, SUM(a.id) AS HIDDEN numArticles FROM User u LEFT JOIN u.Articles a ORDER BY numArticles DESC HAVING numArticles &gt; 10</p>
<p >Your result will be a collection of Users, and not an array with key 0 as User object instance and "numArticles" as the number of articles per user</p>
<h2><a class="anchor" id="autotoc_md304"></a>
Map entities as scalars in DQL result</h2>
<p >When hydrating to array or even a mixed result in object hydrator, previously you had the 0 index holding you entity instance. You are now allowed to alias this, providing more flexibility for you code. Example:</p>
<p >SELECT u AS user FROM User u</p>
<p >Will now return a collection of arrays with index "user" pointing to the User object instance.</p>
<h2><a class="anchor" id="autotoc_md305"></a>
Performance optimizations</h2>
<p >Thousands of lines were completely reviewed and optimized for best performance. Removed redundancy and improved code readability made now internal Doctrine code easier to understand. Also, Doctrine 2.2 now is around 10-15% faster than 2.1.</p>
<h2><a class="anchor" id="autotoc_md306"></a>
EntityManager#find(null)</h2>
<p >Previously EntityManager::find(null) returned null. It now throws an exception.</p>
<h1><a class="anchor" id="autotoc_md307"></a>
Upgrade to 2.1</h1>
<h2><a class="anchor" id="autotoc_md308"></a>
Interface for EntityRepository</h2>
<p >The EntityRepository now has an interface Doctrine\Persistence\ObjectRepository. This means that your classes that override EntityRepository and extend find(), findOneBy() or findBy() must be adjusted to follow this interface.</p>
<h2><a class="anchor" id="autotoc_md309"></a>
AnnotationReader changes</h2>
<p >The annotation reader was heavily refactored between 2.0 and 2.1-RC1. In theory the operation of the new reader should be backwards compatible, but it has to be setup differently to work that way: </p><pre class="fragment">// new call to the AnnotationRegistry
\Doctrine\Common\Annotations\AnnotationRegistry::registerFile('/doctrine-src/lib/Doctrine/ORM/Mapping/Driver/DoctrineAnnotations.php');

$reader = new \Doctrine\Common\Annotations\AnnotationReader();
$reader-&gt;setDefaultAnnotationNamespace('Doctrine\ORM\Mapping\\');
// new code necessary starting here
$reader-&gt;setIgnoreNotImportedAnnotations(true);
$reader-&gt;setEnableParsePhpImports(false);
$reader = new \Doctrine\Common\Annotations\CachedReader(
    new \Doctrine\Common\Annotations\IndexedReader($reader), new ArrayCache()
);
</pre><p> This is already done inside the <code>$config-&gt;newDefaultAnnotationDriver</code>, so everything should automatically work if you are using this method. You can verify if everything still works by executing a console command such as schema-validate that loads all metadata into memory.</p>
<h1><a class="anchor" id="autotoc_md310"></a>
Update from 2.0-BETA3 to 2.0-BETA4</h1>
<h2><a class="anchor" id="autotoc_md311"></a>
XML Driver &lt;change-tracking-policy /&gt; element demoted to attribute</h2>
<p >We changed how the XML Driver allows to define the change-tracking-policy. The working case is now: </p><pre class="fragment">&lt;entity change-tracking-policy="DEFERRED_IMPLICT" /&gt;
</pre> <h1><a class="anchor" id="autotoc_md312"></a>
Update from 2.0-BETA2 to 2.0-BETA3</h1>
<h2><a class="anchor" id="autotoc_md313"></a>
Serialization of Uninitialized Proxies</h2>
<p >As of Beta3 you can now serialize uninitialized proxies, an exception will only be thrown when trying to access methods on the unserialized proxy as long as it has not been re-attached to the EntityManager using <code>EntityManager#merge()</code>. See this example: </p><pre class="fragment">$proxy = $em-&gt;getReference('User', 1);

$serializedProxy = serialize($proxy);
$detachedProxy = unserialized($serializedProxy);

echo $em-&gt;contains($detachedProxy); // FALSE

try {
    $detachedProxy-&gt;getId(); // uninitialized detached proxy
} catch(Exception $e) {

}
$attachedProxy = $em-&gt;merge($detachedProxy);
echo $attackedProxy-&gt;getId(); // works!
</pre> <h2><a class="anchor" id="autotoc_md314"></a>
Changed SQL implementation of Postgres and Oracle DateTime types</h2>
<p >The DBAL Type "datetime" included the Timezone Offset in both Postgres and Oracle. As of this version they are now generated without Timezone (TIMESTAMP WITHOUT TIME ZONE instead of TIMESTAMP WITH TIME ZONE). See <a href="http://www.doctrine-project.org/jira/browse/DBAL-22?focusedCommentId=13396&amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_13396">this comment to Ticket DBAL-22</a> for more details as well as migration issues for PostgreSQL and Oracle.</p>
<p >Both Postgres and Oracle will throw Exceptions during hydration of Objects with "DateTime" fields unless migration steps are taken!</p>
<h2><a class="anchor" id="autotoc_md315"></a>
Removed multi-dot/deep-path expressions in DQL</h2>
<p >The support for implicit joins in DQL through the multi-dot/Deep Path Expressions was dropped. For example: </p><pre class="fragment">SELECT u FROM User u WHERE u.group.name = ?1
</pre><p> See the "u.group.id" here is using multi dots (deep expression) to walk through the graph of objects and properties. Internally the DQL parser would rewrite these queries to: </p><pre class="fragment">SELECT u FROM User u JOIN u.group g WHERE g.name = ?1
</pre><p> This explicit notation will be the only supported notation as of now. The internal handling of multi-dots in the DQL Parser was very complex, error prone in edge cases and required special treatment for several features we added. Additionally it had edge cases that could not be solved without making the DQL Parser even much more complex. For this reason we will drop the support for the deep path expressions to increase maintainability and overall performance of the DQL parsing process. This will benefit any DQL query being parsed, even those not using deep path expressions.</p>
<p >Note that the generated SQL of both notations is exactly the same! You don't loose anything through this.</p>
<h2><a class="anchor" id="autotoc_md316"></a>
Default Allocation Size for Sequences</h2>
<p >The default allocation size for sequences has been changed from 10 to 1. This step was made to not cause confusion with users and also because it is partly some kind of premature optimization.</p>
<h1><a class="anchor" id="autotoc_md317"></a>
Update from 2.0-BETA1 to 2.0-BETA2</h1>
<p >There are no backwards incompatible changes in this release.</p>
<h1><a class="anchor" id="autotoc_md318"></a>
Upgrade from 2.0-ALPHA4 to 2.0-BETA1</h1>
<h2><a class="anchor" id="autotoc_md319"></a>
EntityRepository deprecates access to protected variables</h2>
<p >Instead of accessing protected variables for the EntityManager in a custom EntityRepository it is now required to use the getter methods for all the three instance variables:</p>
<ul>
<li><code>$this-&gt;_em</code> now accessible through <code>$this-&gt;getEntityManager()</code></li>
<li><code>$this-&gt;_class</code> now accessible through <code>$this-&gt;getClassMetadata()</code></li>
<li><code>$this-&gt;_entityName</code> now accessible through <code>$this-&gt;getEntityName()</code></li>
</ul>
<p >Important: For Beta 2 the protected visibility of these three properties will be changed to private!</p>
<h2><a class="anchor" id="autotoc_md320"></a>
Console migrated to Symfony Console</h2>
<p >The Doctrine CLI has been replaced by Symfony Console Configuration</p>
<p >Instead of having to specify: </p><pre class="fragment">[php]
$cliConfig = new CliConfiguration();
$cliConfig-&gt;setAttribute('em', $entityManager);
</pre><p> You now have to configure the script like: </p><pre class="fragment">[php]
$helperSet = new \Symfony\Components\Console\Helper\HelperSet(array(
    'db' =&gt; new \Doctrine\DBAL\Tools\Console\Helper\ConnectionHelper($em-&gt;getConnection()),
    'em' =&gt; new \Doctrine\ORM\Tools\Console\Helper\EntityManagerHelper($em)
));
</pre> <h2><a class="anchor" id="autotoc_md321"></a>
Console: No need for Mapping Paths anymore</h2>
<p >In previous versions you had to specify the &ndash;from and &ndash;from-path options to show where your mapping paths are from the console. However this information is already known from the Mapping Driver configuration, so the requirement for this options were dropped.</p>
<p >Instead for each console command all the entities are loaded and to restrict the operation to one or more sub-groups you can use the &ndash;filter flag.</p>
<h2><a class="anchor" id="autotoc_md322"></a>
AnnotationDriver is not a default mapping driver anymore</h2>
<p >In conjunction with the recent changes to Console we realized that the annotations driver being a default metadata driver lead to lots of glue code in the console components to detect where entities lie and how to load them for batch updates like SchemaTool and other commands. However the annotations driver being a default driver does not really help that much anyways.</p>
<p >Therefore we decided to break backwards compatibility in this issue and drop the support for Annotations as Default Driver and require our users to specify the driver explicitly (which allows us to ask for the path to all entities).</p>
<p >If you are using the annotations metadata driver as default driver, you have to add the following lines to your bootstrap code: </p><pre class="fragment">$driverImpl = $config-&gt;newDefaultAnnotationDriver(array(__DIR__."/Entities"));
$config-&gt;setMetadataDriverImpl($driverImpl);
</pre><p> You have to specify the path to your entities as either string of a single path or array of multiple paths to your entities. This information will be used by all console commands to access all entities.</p>
<p >Xml and Yaml Drivers work as before!</p>
<h2><a class="anchor" id="autotoc_md323"></a>
New inversedBy attribute</h2>
<p >It is now <em>mandatory</em> that the owning side of a bidirectional association specifies the 'inversedBy' attribute that points to the name of the field on the inverse side that completes the association. Example: </p><pre class="fragment">[php]
// BEFORE (ALPHA4 AND EARLIER)
class User
{
    //...
    /** @OneToOne(targetEntity="Address", mappedBy="user") */
    private $address;
    //...
}
class Address
{
    //...
    /** @OneToOne(targetEntity="User") */
    private $user;
    //...
}

// SINCE BETA1
// User class DOES NOT CHANGE
class Address
{
    //...
    /** @OneToOne(targetEntity="User", inversedBy="address") */
    private $user;
    //...
}
</pre><p> Thus, the inversedBy attribute is the counterpart to the mappedBy attribute. This change was necessary to enable some simplifications and further performance improvements. We apologize for the inconvenience.</p>
<h2><a class="anchor" id="autotoc_md324"></a>
Default Property for Field Mappings</h2>
<p >The "default" option for database column defaults has been removed. If desired, database column defaults can be implemented by using the columnDefinition attribute of the @Column annotation (or the appropriate XML and YAML equivalents). Prefer PHP default values, if possible.</p>
<h2><a class="anchor" id="autotoc_md325"></a>
Selecting Partial Objects</h2>
<p >Querying for partial objects now has a new syntax. The old syntax to query for partial objects now has a different meaning. This is best illustrated by an example. If you previously had a DQL query like this: </p><pre class="fragment">[sql]
SELECT u.id, u.name FROM User u
</pre><p> Since BETA1, simple state field path expressions in the select clause are used to select object fields as plain scalar values (something that was not possible before). To achieve the same result as previously (that is, a partial object with only id and name populated) you need to use the following, explicit syntax: </p><pre class="fragment">[sql]
SELECT PARTIAL u.{id,name} FROM User u
</pre> <h2><a class="anchor" id="autotoc_md326"></a>
XML Mapping Driver</h2>
<p >The 'inheritance-type' attribute changed to take last bit of ClassMetadata constant names, i.e. NONE, SINGLE_TABLE, INHERITANCE_TYPE_JOINED</p>
<h2><a class="anchor" id="autotoc_md327"></a>
YAML Mapping Driver</h2>
<p >The way to specify lifecycle callbacks in YAML Mapping driver was changed to allow for multiple callbacks per event. The Old syntax ways: </p><pre class="fragment">[yaml]
lifecycleCallbacks:
  doStuffOnPrePersist: prePersist
  doStuffOnPostPersist: postPersist
</pre><p> The new syntax is: </p><pre class="fragment">[yaml]
lifecycleCallbacks:
  prePersist: [ doStuffOnPrePersist, doOtherStuffOnPrePersistToo ]
  postPersist: [ doStuffOnPostPersist ]
</pre> <h2><a class="anchor" id="autotoc_md328"></a>
PreUpdate Event Listeners</h2>
<p >Event Listeners listening to the 'preUpdate' event can only affect the primitive values of entity changesets by using the API on the <code>PreUpdateEventArgs</code> instance passed to the preUpdate listener method. Any changes to the state of the entitys properties won't affect the database UPDATE statement anymore. This gives drastic performance benefits for the preUpdate event.</p>
<h2><a class="anchor" id="autotoc_md329"></a>
Collection API</h2>
<p >The Collection interface in the Common package has been updated with some missing methods that were present only on the default implementation, ArrayCollection. Custom collection implementations need to be updated to adhere to the updated interface.</p>
<h1><a class="anchor" id="autotoc_md330"></a>
Upgrade from 2.0-ALPHA3 to 2.0-ALPHA4</h1>
<h2><a class="anchor" id="autotoc_md331"></a>
CLI Controller changes</h2>
<p >CLI main object changed its name and namespace. Renamed from Doctrine\ORM\Tools\Cli to Doctrine\Common\Cli\CliController. Doctrine\Common\Cli\CliController now only deals with namespaces. Ready to go, Core, Dbal and Orm are available and you can subscribe new tasks by retrieving the namespace and including new task. Example: </p><pre class="fragment">[php]
$cli-&gt;getNamespace('Core')-&gt;addTask('my-example', '\MyProject\Tools\Cli\Tasks\MyExampleTask');
</pre><h2><a class="anchor" id="autotoc_md332"></a>
CLI Tasks documentation</h2>
<p >Tasks have implemented a new way to build documentation. Although it is still possible to define the help manually by extending the basicHelp and extendedHelp, they are now optional. With new required method AbstractTask::buildDocumentation, its implementation defines the TaskDocumentation instance (accessible through AbstractTask::getDocumentation()), basicHelp and extendedHelp are now not necessary to be implemented.</p>
<h2><a class="anchor" id="autotoc_md333"></a>
Changes in Method Signatures</h2>
<pre class="fragment">* A bunch of Methods on both Doctrine\DBAL\Platforms\AbstractPlatform and Doctrine\DBAL\Schema\AbstractSchemaManager
  have changed quite significantly by adopting the new Schema instance objects.
</pre> <h2><a class="anchor" id="autotoc_md334"></a>
Renamed Methods</h2>
<pre class="fragment">* Doctrine\ORM\AbstractQuery::setExpireResultCache() -&gt; expireResultCache()
* Doctrine\ORM\Query::setExpireQueryCache() -&gt; expireQueryCache()
</pre> <h2><a class="anchor" id="autotoc_md335"></a>
SchemaTool Changes</h2>
<pre class="fragment">* "doctrine schema-tool --drop" now always drops the complete database instead of
only those tables defined by the current database model. The previous method had
problems when foreign keys of orphaned tables pointed to tables that were scheduled
for deletion.
* Use "doctrine schema-tool --update" to get a save incremental update for your
database schema without deleting any unused tables, sequences or foreign keys.
* Use "doctrine schema-tool --complete-update" to do a full incremental update of
your schema.
</pre> <h1><a class="anchor" id="autotoc_md336"></a>
Upgrade from 2.0-ALPHA2 to 2.0-ALPHA3</h1>
<p >This section details the changes made to Doctrine 2.0-ALPHA3 to make it easier for you to upgrade your projects to use this version.</p>
<h2><a class="anchor" id="autotoc_md337"></a>
CLI Changes</h2>
<p >The $args variable used in the cli-config.php for configuring the Doctrine CLI has been renamed to $globalArguments.</p>
<h2><a class="anchor" id="autotoc_md338"></a>
Proxy class changes</h2>
<p >You are now required to make supply some minimalist configuration with regards to proxy objects. That involves 2 new configuration options. First, the directory where generated proxy classes should be placed needs to be specified. Secondly, you need to configure the namespace used for proxy classes. The following snippet shows an example: </p><pre class="fragment">[php]
// step 1: configure directory for proxy classes
// $config instanceof Doctrine\ORM\Configuration
$config-&gt;setProxyDir('/path/to/myproject/lib/MyProject/Generated/Proxies');
$config-&gt;setProxyNamespace('MyProject\Generated\Proxies');
</pre><p> Note that proxy classes behave exactly like any other classes when it comes to class loading. Therefore you need to make sure the proxy classes can be loaded by some class loader. If you place the generated proxy classes in a namespace and directory under your projects class files, like in the example above, it would be sufficient to register the MyProject namespace on a class loader. Since the proxy classes are contained in that namespace and adhere to the standards for class loading, no additional work is required. Generating the proxy classes into a namespace within your class library is the recommended setup.</p>
<p >Entities with initialized proxy objects can now be serialized and unserialized properly from within the same application.</p>
<p >For more details refer to the Configuration section of the manual.</p>
<h2><a class="anchor" id="autotoc_md339"></a>
Removed allowPartialObjects configuration option</h2>
<p >The allowPartialObjects configuration option together with the <code>Configuration#getAllowPartialObjects</code> and <code>Configuration#setAllowPartialObjects</code> methods have been removed. The new behavior is as if the option were set to FALSE all the time, basically disallowing partial objects globally. However, you can still use the <code>Query::HINT_FORCE_PARTIAL_LOAD</code> query hint to force a query to return partial objects for optimization purposes.</p>
<h2><a class="anchor" id="autotoc_md340"></a>
Renamed Methods</h2>
<ul>
<li>Doctrine\ORM\Configuration#getCacheDir() to getProxyDir()</li>
<li>Doctrine\ORM\Configuration#setCacheDir($dir) to setProxyDir($dir) </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
