<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>village green: Loop Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">village green
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Amp</b></li><li class="navelem"><a class="el" href="class_amp_1_1_loop.html">Loop</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">Loop Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a70f26f7ad46c72523707f504c4f119a1"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a70f26f7ad46c72523707f504c4f119a1">set</a> (<a class="el" href="class_amp_1_1_loop_1_1_driver.html">Driver</a> $driver)</td></tr>
<tr class="separator:a70f26f7ad46c72523707f504c4f119a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fe3737f4b3328c4c45f9b071c2f85c"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a69fe3737f4b3328c4c45f9b071c2f85c">run</a> (callable $callback=null)</td></tr>
<tr class="separator:a69fe3737f4b3328c4c45f9b071c2f85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c3c0c2fc53579e9d1ac28a52623450"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a00c3c0c2fc53579e9d1ac28a52623450">stop</a> ()</td></tr>
<tr class="separator:a00c3c0c2fc53579e9d1ac28a52623450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab249e36c82c1aa8c187cc5a33db7256a"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#ab249e36c82c1aa8c187cc5a33db7256a">defer</a> (callable $callback, $data=null)</td></tr>
<tr class="separator:ab249e36c82c1aa8c187cc5a33db7256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236ecaf933a3498392497e999b3e677c"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a236ecaf933a3498392497e999b3e677c">delay</a> (int $delay, callable $callback, $data=null)</td></tr>
<tr class="separator:a236ecaf933a3498392497e999b3e677c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66574698574715b5772256f5998deea"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#aa66574698574715b5772256f5998deea">repeat</a> (int $interval, callable $callback, $data=null)</td></tr>
<tr class="separator:aa66574698574715b5772256f5998deea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8f25d655922a63f5799e7529943868"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a1d8f25d655922a63f5799e7529943868">onReadable</a> ($stream, callable $callback, $data=null)</td></tr>
<tr class="separator:a1d8f25d655922a63f5799e7529943868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bb5c5cb82cc413dc6f069d81fad31c"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a75bb5c5cb82cc413dc6f069d81fad31c">onWritable</a> ($stream, callable $callback, $data=null)</td></tr>
<tr class="separator:a75bb5c5cb82cc413dc6f069d81fad31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9ce2ce04393715a6d80803cad1187e"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#aae9ce2ce04393715a6d80803cad1187e">onSignal</a> (int $signo, callable $callback, $data=null)</td></tr>
<tr class="separator:aae9ce2ce04393715a6d80803cad1187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17aec725526d2b0874f5ed2927b5f8ce"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a17aec725526d2b0874f5ed2927b5f8ce">enable</a> (string $watcherId)</td></tr>
<tr class="separator:a17aec725526d2b0874f5ed2927b5f8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14f859352356574fc168da4f791a4c1"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#ae14f859352356574fc168da4f791a4c1">disable</a> (string $watcherId)</td></tr>
<tr class="separator:ae14f859352356574fc168da4f791a4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb9917ec3d532e2ef42546f72aca27f"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#aafb9917ec3d532e2ef42546f72aca27f">cancel</a> (string $watcherId)</td></tr>
<tr class="separator:aafb9917ec3d532e2ef42546f72aca27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595dc390542fadffe8ac3c22051fc318"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a595dc390542fadffe8ac3c22051fc318">reference</a> (string $watcherId)</td></tr>
<tr class="separator:a595dc390542fadffe8ac3c22051fc318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d8514b2e464b897e2f8003fd2c0597"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a77d8514b2e464b897e2f8003fd2c0597">unreference</a> (string $watcherId)</td></tr>
<tr class="separator:a77d8514b2e464b897e2f8003fd2c0597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e393aa6d7074ae6ddc34df2ed39c03"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#af1e393aa6d7074ae6ddc34df2ed39c03">now</a> ()</td></tr>
<tr class="separator:af1e393aa6d7074ae6ddc34df2ed39c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290aacd82bc937c4af5c4ec076d4baf2"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a290aacd82bc937c4af5c4ec076d4baf2">setState</a> (string $key, $value)</td></tr>
<tr class="separator:a290aacd82bc937c4af5c4ec076d4baf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6b2fafbf5fad10c4127a28fd045ac3"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a2a6b2fafbf5fad10c4127a28fd045ac3">getState</a> (string $key)</td></tr>
<tr class="separator:a2a6b2fafbf5fad10c4127a28fd045ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b30117a11a1427d4c985ad038db85"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#afd3b30117a11a1427d4c985ad038db85">setErrorHandler</a> (callable $callback=null)</td></tr>
<tr class="separator:afd3b30117a11a1427d4c985ad038db85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb696f53ab37f19ae1621f238002a5ae"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#aeb696f53ab37f19ae1621f238002a5ae">getInfo</a> ()</td></tr>
<tr class="separator:aeb696f53ab37f19ae1621f238002a5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba61361bf0695a285bbaefefc427191"><td class="memItemLeft" align="right" valign="top">static&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_amp_1_1_loop.html#a5ba61361bf0695a285bbaefefc427191">get</a> ()</td></tr>
<tr class="separator:a5ba61361bf0695a285bbaefefc427191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Accessor to allow global access to the event loop.</p>
<dl class="section see"><dt>See also</dt><dd>\Amp\Loop\Driver </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aafb9917ec3d532e2ef42546f72aca27f" name="aafb9917ec3d532e2ef42546f72aca27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb9917ec3d532e2ef42546f72aca27f">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static cancel </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>$watcherId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Cancel a watcher.</p>
<p >This will detatch the event loop from all resources that are associated to the watcher. After this operation the watcher is permanently invalid. Calling this function MUST NOT fail, even if passed an invalid watcher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$watcherId</td><td>The watcher identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ab249e36c82c1aa8c187cc5a33db7256a" name="ab249e36c82c1aa8c187cc5a33db7256a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab249e36c82c1aa8c187cc5a33db7256a">&#9670;&nbsp;</a></span>defer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static defer </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$data</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Defer the execution of a callback.</p>
<p >The deferred callable MUST be executed before any other type of watcher in a tick. Order of enabling MUST be preserved when executing the callbacks.</p>
<p >The created watcher MUST immediately be marked as enabled, but only be activated (i.e. callback can be called) right before the next tick. Callbacks of watchers MUST NOT be called in the tick they were enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype"></td><td class="paramname">callable(string</td><td>$watcherId, mixed $data) $callback The callback to defer. The <code>$watcherId</code> will be invalidated before the callback call. </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$data</td><td>Arbitrary data given to the callback function as the <code>$data</code> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string An unique identifier that can be used to cancel, enable or disable the watcher. </dd></dl>

</div>
</div>
<a id="a236ecaf933a3498392497e999b3e677c" name="a236ecaf933a3498392497e999b3e677c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236ecaf933a3498392497e999b3e677c">&#9670;&nbsp;</a></span>delay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static delay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>$delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$data</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delay the execution of a callback.</p>
<p >The delay is a minimum and approximate, accuracy is not guaranteed. Order of calls MUST be determined by which timers expire first, but timers with the same expiration time MAY be executed in any order.</p>
<p >The created watcher MUST immediately be marked as enabled, but only be activated (i.e. callback can be called) right before the next tick. Callbacks of watchers MUST NOT be called in the tick they were enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int</td><td class="paramname">$delay</td><td>The amount of time, in milliseconds, to delay the execution for. </td></tr>
    <tr><td class="paramtype"></td><td class="paramname">callable(string</td><td>$watcherId, mixed $data) $callback The callback to delay. The <code>$watcherId</code> will be invalidated before the callback call. </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$data</td><td>Arbitrary data given to the callback function as the <code>$data</code> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string An unique identifier that can be used to cancel, enable or disable the watcher. </dd></dl>

</div>
</div>
<a id="ae14f859352356574fc168da4f791a4c1" name="ae14f859352356574fc168da4f791a4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14f859352356574fc168da4f791a4c1">&#9670;&nbsp;</a></span>disable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static disable </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>$watcherId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Disable a watcher immediately.</p>
<p >A watcher MUST be disabled immediately, e.g. if a defer watcher disables a later defer watcher, the second defer watcher isn't executed in this tick.</p>
<p >Disabling a watcher MUST NOT invalidate the watcher. Calling this function MUST NOT fail, even if passed an invalid watcher.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$watcherId</td><td>The watcher identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a17aec725526d2b0874f5ed2927b5f8ce" name="a17aec725526d2b0874f5ed2927b5f8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17aec725526d2b0874f5ed2927b5f8ce">&#9670;&nbsp;</a></span>enable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enable </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>$watcherId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enable a watcher to be active starting in the next tick.</p>
<p >Watchers MUST immediately be marked as enabled, but only be activated (i.e. callbacks can be called) right before the next tick. Callbacks of watchers MUST NOT be called in the tick they were enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$watcherId</td><td>The watcher identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_amp_1_1_loop_1_1_invalid_watcher_error.html">InvalidWatcherError</a></td><td>If the watcher identifier is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ba61361bf0695a285bbaefefc427191" name="a5ba61361bf0695a285bbaefefc427191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba61361bf0695a285bbaefefc427191">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Retrieve the event loop driver that is in scope.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_amp_1_1_loop_1_1_driver.html">Driver</a> </dd></dl>

</div>
</div>
<a id="aeb696f53ab37f19ae1621f238002a5ae" name="aeb696f53ab37f19ae1621f238002a5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb696f53ab37f19ae1621f238002a5ae">&#9670;&nbsp;</a></span>getInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static getInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Retrieve an associative array of information about the event loop driver.</p>
<p >The returned array MUST contain the following data describing the driver's currently registered watchers: </p><pre class="fragment">[
    "defer"            =&gt; ["enabled" =&gt; int, "disabled" =&gt; int],
    "delay"            =&gt; ["enabled" =&gt; int, "disabled" =&gt; int],
    "repeat"           =&gt; ["enabled" =&gt; int, "disabled" =&gt; int],
    "on_readable"      =&gt; ["enabled" =&gt; int, "disabled" =&gt; int],
    "on_writable"      =&gt; ["enabled" =&gt; int, "disabled" =&gt; int],
    "on_signal"        =&gt; ["enabled" =&gt; int, "disabled" =&gt; int],
    "enabled_watchers" =&gt; ["referenced" =&gt; int, "unreferenced" =&gt; int],
    "running"          =&gt; bool
];
</pre><p> Implementations MAY optionally add more information in the array but at minimum the above <code>key =&gt; value</code> format MUST always be provided.</p>
<dl class="section return"><dt>Returns</dt><dd>array Statistics about the loop in the described format. </dd></dl>

</div>
</div>
<a id="a2a6b2fafbf5fad10c4127a28fd045ac3" name="a2a6b2fafbf5fad10c4127a28fd045ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6b2fafbf5fad10c4127a28fd045ac3">&#9670;&nbsp;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static getState </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>$key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Gets information stored bound to the loop.</p>
<p >Stored information is package private. Packages MUST NOT retrieve the stored state of other packages. Packages MUST use their namespace as prefix for keys. They may do so by using <code>SomeClass::class</code> as key.</p>
<p >If packages want to expose loop bound state to consumers other than the package, they SHOULD provide a dedicated interface for that purpose instead of sharing the storage key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$key</td><td>The namespaced storage key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mixed The previously stored value or <code>null</code> if it doesn't exist. </dd></dl>

</div>
</div>
<a id="af1e393aa6d7074ae6ddc34df2ed39c03" name="af1e393aa6d7074ae6ddc34df2ed39c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e393aa6d7074ae6ddc34df2ed39c03">&#9670;&nbsp;</a></span>now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static now </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the current loop time in millisecond increments. Note this value does not necessarily correlate to wall-clock time, rather the value returned is meant to be used in relative comparisons to prior values returned by this method (intervals, expiration calculations, etc.) and is only updated once per loop tick.</p>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a1d8f25d655922a63f5799e7529943868" name="a1d8f25d655922a63f5799e7529943868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8f25d655922a63f5799e7529943868">&#9670;&nbsp;</a></span>onReadable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static onReadable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$data</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Execute a callback when a stream resource becomes readable or is closed for reading.</p>
<p >Warning: Closing resources locally, e.g. with <code>fclose</code>, might not invoke the callback. Be sure to <code>cancel</code> the watcher when closing the resource locally. Drivers MAY choose to notify the user if there are watchers on invalid resources, but are not required to, due to the high performance impact. Watchers on closed resources are therefore undefined behavior.</p>
<p >Multiple watchers on the same stream MAY be executed in any order.</p>
<p >The created watcher MUST immediately be marked as enabled, but only be activated (i.e. callback can be called) right before the next tick. Callbacks of watchers MUST NOT be called in the tick they were enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">resource</td><td class="paramname">$stream</td><td>The stream to monitor. </td></tr>
    <tr><td class="paramtype"></td><td class="paramname">callable(string</td><td>$watcherId, resource $stream, mixed $data) $callback The callback to execute. </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$data</td><td>Arbitrary data given to the callback function as the <code>$data</code> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string An unique identifier that can be used to cancel, enable or disable the watcher. </dd></dl>

</div>
</div>
<a id="aae9ce2ce04393715a6d80803cad1187e" name="aae9ce2ce04393715a6d80803cad1187e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9ce2ce04393715a6d80803cad1187e">&#9670;&nbsp;</a></span>onSignal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static onSignal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>$signo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$data</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Execute a callback when a signal is received.</p>
<p >Warning: Installing the same signal on different instances of this interface is deemed undefined behavior. Implementations MAY try to detect this, if possible, but are not required to. This is due to technical limitations of the signals being registered globally per process.</p>
<p >Multiple watchers on the same signal MAY be executed in any order.</p>
<p >The created watcher MUST immediately be marked as enabled, but only be activated (i.e. callback can be called) right before the next tick. Callbacks of watchers MUST NOT be called in the tick they were enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int</td><td class="paramname">$signo</td><td>The signal number to monitor. </td></tr>
    <tr><td class="paramtype"></td><td class="paramname">callable(string</td><td>$watcherId, int $signo, mixed $data) $callback The callback to execute. </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$data</td><td>Arbitrary data given to the callback function as the $data parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string An unique identifier that can be used to cancel, enable or disable the watcher.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_amp_1_1_loop_1_1_unsupported_feature_exception.html">UnsupportedFeatureException</a></td><td>If signal handling is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75bb5c5cb82cc413dc6f069d81fad31c" name="a75bb5c5cb82cc413dc6f069d81fad31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bb5c5cb82cc413dc6f069d81fad31c">&#9670;&nbsp;</a></span>onWritable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static onWritable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$data</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Execute a callback when a stream resource becomes writable or is closed for writing.</p>
<p >Warning: Closing resources locally, e.g. with <code>fclose</code>, might not invoke the callback. Be sure to <code>cancel</code> the watcher when closing the resource locally. Drivers MAY choose to notify the user if there are watchers on invalid resources, but are not required to, due to the high performance impact. Watchers on closed resources are therefore undefined behavior.</p>
<p >Multiple watchers on the same stream MAY be executed in any order.</p>
<p >The created watcher MUST immediately be marked as enabled, but only be activated (i.e. callback can be called) right before the next tick. Callbacks of watchers MUST NOT be called in the tick they were enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">resource</td><td class="paramname">$stream</td><td>The stream to monitor. </td></tr>
    <tr><td class="paramtype"></td><td class="paramname">callable(string</td><td>$watcherId, resource $stream, mixed $data) $callback The callback to execute. </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$data</td><td>Arbitrary data given to the callback function as the <code>$data</code> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string An unique identifier that can be used to cancel, enable or disable the watcher. </dd></dl>

</div>
</div>
<a id="a595dc390542fadffe8ac3c22051fc318" name="a595dc390542fadffe8ac3c22051fc318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595dc390542fadffe8ac3c22051fc318">&#9670;&nbsp;</a></span>reference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static reference </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>$watcherId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reference a watcher.</p>
<p >This will keep the event loop alive whilst the watcher is still being monitored. Watchers have this state by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$watcherId</td><td>The watcher identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_amp_1_1_loop_1_1_invalid_watcher_error.html">InvalidWatcherError</a></td><td>If the watcher identifier is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa66574698574715b5772256f5998deea" name="aa66574698574715b5772256f5998deea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66574698574715b5772256f5998deea">&#9670;&nbsp;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static repeat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>$interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$data</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Repeatedly execute a callback.</p>
<p >The interval between executions is a minimum and approximate, accuracy is not guaranteed. Order of calls MUST be determined by which timers expire first, but timers with the same expiration time MAY be executed in any order. The first execution is scheduled after the first interval period.</p>
<p >The created watcher MUST immediately be marked as enabled, but only be activated (i.e. callback can be called) right before the next tick. Callbacks of watchers MUST NOT be called in the tick they were enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">int</td><td class="paramname">$interval</td><td>The time interval, in milliseconds, to wait between executions. </td></tr>
    <tr><td class="paramtype"></td><td class="paramname">callable(string</td><td>$watcherId, mixed $data) $callback The callback to repeat. </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$data</td><td>Arbitrary data given to the callback function as the <code>$data</code> parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string An unique identifier that can be used to cancel, enable or disable the watcher. </dd></dl>

</div>
</div>
<a id="a69fe3737f4b3328c4c45f9b071c2f85c" name="a69fe3737f4b3328c4c45f9b071c2f85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fe3737f4b3328c4c45f9b071c2f85c">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static run </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Run the event loop and optionally execute a callback within the scope of it.</p>
<p >The loop MUST continue to run until it is either stopped explicitly, no referenced watchers exist anymore, or an exception is thrown that cannot be handled. Exceptions that cannot be handled are exceptions thrown from an error handler or exceptions that would be passed to an error handler but none exists to handle them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">callable&#160;|&#160;null</td><td class="paramname">$callback</td><td>The callback to execute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a70f26f7ad46c72523707f504c4f119a1" name="a70f26f7ad46c72523707f504c4f119a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f26f7ad46c72523707f504c4f119a1">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_amp_1_1_loop_1_1_driver.html">Driver</a>&#160;</td>
          <td class="paramname"><em>$driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the driver to be used for <code><a class="el" href="class_amp_1_1_loop.html#a69fe3737f4b3328c4c45f9b071c2f85c">Loop::run()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype"><a class="el" href="class_amp_1_1_loop_1_1_driver.html">Driver</a></td><td class="paramname">$driver</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd>
<dd>
void</dd>
<dd>
void</dd></dl>

</div>
</div>
<a id="afd3b30117a11a1427d4c985ad038db85" name="afd3b30117a11a1427d4c985ad038db85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3b30117a11a1427d4c985ad038db85">&#9670;&nbsp;</a></span>setErrorHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static setErrorHandler </td>
          <td>(</td>
          <td class="paramtype">callable&#160;</td>
          <td class="paramname"><em>$callback</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Set a callback to be executed when an error occurs.</p>
<p >The callback receives the error as the first and only parameter. The return value of the callback gets ignored. If it can't handle the error, it MUST throw the error. Errors thrown by the callback or during its invocation MUST be thrown into the <code>run</code> loop and stop the driver.</p>
<p >Subsequent calls to this method will overwrite the previous handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">\Throwable</td><td class="paramname">callable(,$error,)|null</td><td>$callback The callback to execute. <code>null</code> will clear the current handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>callable(\Throwable $error)|null The previous handler, <code>null</code> if there was none. </dd></dl>

</div>
</div>
<a id="a290aacd82bc937c4af5c4ec076d4baf2" name="a290aacd82bc937c4af5c4ec076d4baf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290aacd82bc937c4af5c4ec076d4baf2">&#9670;&nbsp;</a></span>setState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static setState </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>$key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>$value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stores information in the loop bound registry.</p>
<p >Stored information is package private. Packages MUST NOT retrieve the stored state of other packages. Packages MUST use their namespace as prefix for keys. They may do so by using <code>SomeClass::class</code> as key.</p>
<p >If packages want to expose loop bound state to consumers other than the package, they SHOULD provide a dedicated interface for that purpose instead of sharing the storage key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$key</td><td>The namespaced storage key. </td></tr>
    <tr><td class="paramtype">mixed</td><td class="paramname">$value</td><td>The value to be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a00c3c0c2fc53579e9d1ac28a52623450" name="a00c3c0c2fc53579e9d1ac28a52623450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c3c0c2fc53579e9d1ac28a52623450">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Stop the event loop.</p>
<p >When an event loop is stopped, it continues with its current tick and exits the loop afterwards. Multiple calls to stop MUST be ignored and MUST NOT raise an exception.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a77d8514b2e464b897e2f8003fd2c0597" name="a77d8514b2e464b897e2f8003fd2c0597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d8514b2e464b897e2f8003fd2c0597">&#9670;&nbsp;</a></span>unreference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unreference </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>$watcherId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Unreference a watcher.</p>
<p >The event loop should exit the run method when only unreferenced watchers are still being monitored. Watchers are all referenced by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramtype">string</td><td class="paramname">$watcherId</td><td>The watcher identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>vendor/amphp/amp/lib/Loop.php</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
